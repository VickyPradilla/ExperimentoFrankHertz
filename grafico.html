<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experimento de Franck y Hertz</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .graph-container {
            position: relative;
            width: 100%;
            height: 400px;
            margin-bottom: 20px;
        }
        
        canvas {
            background-color: white;
            border: 1px solid #ddd;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex-grow: 1;
        }
        
        .mode-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .voltage-display {
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        .info {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        }
        
        .peaks-info {
            background-color: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Experimento de Franck y Hertz - Mercurio</h1>
        <p>Gráfica Corriente (I) vs Voltaje (V) mostrando los picos de excitación</p>
        
        <div class="graph-container">
            <canvas id="graphCanvas" width="750" height="400"></canvas>
        </div>
        
        <div class="controls">
            <div class="mode-selector">
                <button id="autoModeBtn">Barrido Automático</button>
                <button id="manualModeBtn">Modo Manual</button>
                <button id="resetBtn">Reiniciar</button>
            </div>
            
            <div class="slider-container">
                <span>Voltaje (V):</span>
                <input type="range" id="voltageSlider" class="slider" min="0" max="20" step="0.1" value="0">
                <span class="voltage-display" id="voltageValue">0.0</span>
            </div>
        </div>
        
        <div class="peaks-info">
            <p><strong>Picos característicos del mercurio:</strong></p>
            <ul>
                <li>Primer pico: ~4.9 V (energía de excitación fundamental)</li>
                <li>Segundo pico: ~9.8 V (2× energía de excitación)</li>
                <li>Tercer pico: ~14.7 V (3× energía de excitación)</li>
            </ul>
        </div>
        
        <div class="info">
            <p>Interpretación:</p>
            <ul>
                <li>Los <strong>máximos</strong> indican voltajes donde no hay pérdida de energía por colisión inelástica.</li>
                <li>Los <strong>valles</strong> representan voltajes donde ocurren colisiones inelásticas que reducen la corriente.</li>
                <li>La separación entre picos (~4.9V) revela la energía de excitación del mercurio.</li>
            </ul>
        </div>
    </div>

    <script>
        // Configuración del canvas y gráfico
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // Elementos de la interfaz
        const voltageSlider = document.getElementById('voltageSlider');
        const voltageValue = document.getElementById('voltageValue');
        const autoModeBtn = document.getElementById('autoModeBtn');
        const manualModeBtn = document.getElementById('manualModeBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        // Variables de estado
        let currentMode = 'manual'; // 'manual' o 'auto'
        let isAutoRunning = false;
        let autoInterval;
        let recordedPoints = [];
        
        // Configuración del gráfico
        const margin = 50;
        const graphWidth = canvas.width - 2 * margin;
        const graphHeight = canvas.height - 2 * margin;
        
        // Puntos clave del experimento (basados en tus datos)
        const keyPoints = [
            { V: 0.0, I: 0.0 },
            { V: 3.0, I: 0.4 },
            { V: 4.0, I: 1.2 },
            { V: 4.9, I: 3.0 },  // Primer pico
            { V: 5.3, I: 2.5 },
            { V: 6.0, I: 1.0 },
            { V: 7.5, I: 1.3 },
            { V: 9.0, I: 2.5 },
            { V: 9.8, I: 3.2 },  // Segundo pico
            { V: 10.4, I: 2.7 },
            { V: 11.2, I: 1.4 },
            { V: 12.5, I: 1.8 },
            { V: 14.0, I: 2.8 },
            { V: 14.7, I: 3.4 },  // Tercer pico
            { V: 15.2, I: 2.9 },
            { V: 16.0, I: 1.8 },
            { V: 17.0, I: 2.0 },
            { V: 18.0, I: 2.3 },
            { V: 19.0, I: 2.6 },
            { V: 20.0, I: 2.9 }
        ];
        
        // Función para interpolar entre los puntos clave
        function getCurrentForVoltage(V) {
            // Encontrar los puntos adyacentes
            let prevPoint = keyPoints[0];
            let nextPoint = keyPoints[keyPoints.length - 1];
            
            for (let i = 1; i < keyPoints.length; i++) {
                if (keyPoints[i].V >= V) {
                    prevPoint = keyPoints[i - 1];
                    nextPoint = keyPoints[i];
                    break;
                }
            }
            
            // Interpolación lineal
            if (prevPoint.V === nextPoint.V) return prevPoint.I;
            
            const ratio = (V - prevPoint.V) / (nextPoint.V - prevPoint.V);
            return prevPoint.I + ratio * (nextPoint.I - prevPoint.I);
        }
        
        // Dibujar ejes y cuadrícula
        function drawAxes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar cuadrícula
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Líneas verticales (voltaje)
            for (let v = 0; v <= 20; v += 1) {
                const x = margin + (v / 20) * graphWidth;
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, margin + graphHeight);
                ctx.stroke();
                
                // Etiquetas de voltaje
                if (v % 2 === 0) {
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.font = '12px Arial';
                    ctx.fillText(v + 'V', x, margin + graphHeight + 20);
                }
            }
            
            // Líneas horizontales (corriente)
            for (let i = 0; i <= 4; i += 0.5) {
                const y = margin + graphHeight - (i / 4) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(margin + graphWidth, y);
                ctx.stroke();
                
                // Etiquetas de corriente
                if (i % 1 === 0) {
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'right';
                    ctx.font = '12px Arial';
                    ctx.fillText(i.toFixed(1) + ' µA', margin - 10, y + 5);
                }
            }
            
            // Dibujar ejes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // Eje X (Voltaje)
            ctx.beginPath();
            ctx.moveTo(margin, margin + graphHeight);
            ctx.lineTo(margin + graphWidth, margin + graphHeight);
            ctx.stroke();
            
            // Eje Y (Corriente)
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + graphHeight);
            ctx.stroke();
            
            // Etiquetas de los ejes
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.font = '14px Arial';
            ctx.fillText('Voltaje (V)', canvas.width / 2, canvas.height - 10);
            
            ctx.save();
            ctx.translate(25, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Corriente (µA)', 0, 0);
            ctx.restore();
        }
        
        // Dibujar puntos y línea de la gráfica
        function drawGraph() {
            if (recordedPoints.length === 0) return;
            
            // Ordenar puntos por voltaje
            recordedPoints.sort((a, b) => a.V - b.V);
            
            // Dibujar línea
            ctx.strokeStyle = '#003366'; // Azul oscuro
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const firstPoint = recordedPoints[0];
            const x = margin + (firstPoint.V / 20) * graphWidth;
            const y = margin + graphHeight - (firstPoint.I / 4) * graphHeight;
            ctx.moveTo(x, y);
            
            for (let i = 1; i < recordedPoints.length; i++) {
                const point = recordedPoints[i];
                const x = margin + (point.V / 20) * graphWidth;
                const y = margin + graphHeight - (point.I / 4) * graphHeight;
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Dibujar puntos
            ctx.fillStyle = '#FF8C00'; // Naranja
            for (const point of recordedPoints) {
                const x = margin + (point.V / 20) * graphWidth;
                const y = margin + graphHeight - (point.I / 4) * graphHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Marcar los picos importantes
            const peaks = [
                { V: 4.9, label: "1er pico (4.9V)" },
                { V: 9.8, label: "2do pico (9.8V)" },
                { V: 14.7, label: "3er pico (14.7V)" }
            ];
            
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.font = '12px Arial';
            
            for (const peak of peaks) {
                const point = recordedPoints.find(p => Math.abs(p.V - peak.V) < 0.2);
                if (point) {
                    const x = margin + (point.V / 20) * graphWidth;
                    const y = margin + graphHeight - (point.I / 4) * graphHeight;
                    
                    // Dibujar línea punteada hasta el pico
                    ctx.setLineDash([2, 2]);
                    ctx.strokeStyle = '#888';
                    ctx.beginPath();
                    ctx.moveTo(x, margin + graphHeight);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Etiqueta del pico
                    ctx.fillText(peak.label, x, y - 15);
                }
            }
        }
        
        // Actualizar gráfico con nuevo punto
        function updateGraph(V) {
            // Verificar si este voltaje ya fue registrado
            const exists = recordedPoints.some(point => Math.abs(point.V - V) < 0.1);
            if (exists) return;
            
            // Obtener corriente para este voltaje
            const I = getCurrentForVoltage(V);
            
            // Añadir a los puntos registrados
            recordedPoints.push({ V, I });
            
            // Redibujar todo
            drawAxes();
            drawGraph();
        }
        
        // Modo automático
        function startAutoMode() {
            if (isAutoRunning) return;
            
            currentMode = 'auto';
            isAutoRunning = true;
            autoModeBtn.disabled = true;
            manualModeBtn.disabled = false;
            voltageSlider.disabled = true;
            
            let currentV = 0;
            const step = 0.1;
            const delay = 100; // ms entre pasos
            
            autoInterval = setInterval(() => {
                currentV += step;
                if (currentV > 20) {
                    stopAutoMode();
                    return;
                }
                
                voltageSlider.value = currentV;
                voltageValue.textContent = currentV.toFixed(1);
                updateGraph(currentV);
            }, delay);
        }
        
        function stopAutoMode() {
            clearInterval(autoInterval);
            isAutoRunning = false;
            autoModeBtn.disabled = false;
            manualModeBtn.disabled = false;
            voltageSlider.disabled = false;
        }
        
        // Modo manual
        function setManualMode() {
            if (currentMode === 'manual') return;
            
            stopAutoMode();
            currentMode = 'manual';
            manualModeBtn.disabled = true;
            autoModeBtn.disabled = false;
            voltageSlider.disabled = false;
        }
        
        // Reiniciar simulación
        function resetSimulation() {
            stopAutoMode();
            recordedPoints = [];
            voltageSlider.value = 0;
            voltageValue.textContent = '0.0';
            drawAxes();
        }
        
        // Event listeners
        voltageSlider.addEventListener('input', () => {
            const V = parseFloat(voltageSlider.value);
            voltageValue.textContent = V.toFixed(1);
            
            if (currentMode === 'manual') {
                updateGraph(V);
            }
        });
        
        autoModeBtn.addEventListener('click', startAutoMode);
        manualModeBtn.addEventListener('click', setManualMode);
        resetBtn.addEventListener('click', resetSimulation);
        
        // Inicialización
        function init() {
            drawAxes();
            manualModeBtn.disabled = true; // Comenzar en modo manual
        }
        
        init();
    </script>
</body>
</html>
